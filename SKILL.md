---
name: deep-plan
description: |
  优先级高于 plan mode！当用户请求涉及多模块、多维度分析时，必须使用此 skill。

  触发条件（满足任一）：
  • 分析/重构/设计 ≥3 个模块
  • 涉及 ≥2 个维度（性能+安全、功能+测试+文档等）
  • 需要并行探索多个代码区域
  • 用户明确要求"深度分析"、"全面评估"、"多维度"

  何时使用 plan mode：
  • 单文件/单模块修改
  • 明确的小功能开发
  • 单一维度任务（仅性能、仅安全等）

trigger_keywords:
  # 强制触发信号（高优先级）
  - 深度分析
  - 全面评估
  - 多维度
  - 并行分析
  - 多 agent
  - 全面架构分析
  - 系统级设计

  # 上下文组合信号（关键词 + 范围）
  - 分析整体架构
  - 评估系统设计
  - 重构核心模块
  - 设计插件架构
  - 优化全面方案
  - 跨模块重构

  # 原有关键词（保留）
  - 分析架构
  - 重构
  - 设计方案
  - 改进方向
  - 优化方案
complexity: high
multi_agent: true

<example>
## 适用场景示例

### ✅ 适用 deep-plan（多维度 + 深度探索）

**场景 1：架构分析**
用户输入：
- "分析当前架构，提出改进方案"
- "评估模块化设计的合理性"

适用理由：
- 涉及多个模块/文件
- 需要架构层面的思考
- 包含多个维度（功能+性能+可维护性）

**场景 2：系统重构**
用户输入：
- "重构模块加载系统以支持插件"
- "优化命令执行流程以提升性能"

适用理由：
- 涉及核心架构修改
- 需要评估影响范围
- 需要兼容性考虑

**场景 3：多维度优化**
用户输入：
- "优化性能并加强���全性"
- "改进代码可维护性并补充测试"

适用理由：
- 明确涉及 ≥2 个维度
- 维度之间可能有冲突需要协调

### ❌ 不适用（使用 plan mode 或直接执行）

**场景 1：单文件修改**
用户输入：
- "添加一个新命令到 core 模块"
- "修复这个函数的类型错误"

应使用：plan mode（直接规划）

**场景 2：明确的小功能**
用户输入：
- "为这个类添加单元测试"
- "更新这个文档的版本号"

应使用：直接执行（无需规划）

**场景 3：单一维度任务**
用户输入：
- "优化这个查询的性能"
- "修复这个安全漏洞"

应使用：plan mode（单维度无需多 agent）
</example>

---

## ⚠️ 触发优先级

**重要**：此 skill 优先级高于 plan mode！

### 何时使用此 skill

```
用户请求匹配以下任一模式：
  ├─ 包含"深度分析"、"全面评估"、"多维度"
  ├─ 涉及 ≥3 个模块的架构分析/重构
  ├─ 明确涉及 ≥2 个维度（性能+安全、功能+测试等）
  └─ 要求"并行分析"或"多 agent 协作"

→ 必须使用此 skill，切勿使用 plan mode！
```

### 何时使用 plan mode

```
用户请求属于以下任一情况：
  ├─ 单文件/单模块修改
  ├─ 明确的小功能开发
  ├─ 单一维度任务（仅性能、仅安全等）
  └─ 简单的代码探索和修改

→ 使用 plan mode 或直接执行
```

---

你是深度规划助手。严格遵循以下流程。

# 🚀 快速开始（10 行内）

## 何时使用
多模块（≥3）+ 多维度（≥2）+ 深度探索 → deep-plan ⭐

## 核心流程（6 步）
1. 需求澄清（Phase 1）
2. 场景识别（Phase 2）
3. 多 Agent 协作（Phase 3）← 关键
4. 代码探索（Phase 4）
5. 计划生成（Phase 5）
6. 验证输出（Phase 6-7）

## 关键原则
- ✅ 渐进式发现：描述任务，让框架自动选工具
- ✅ 澄清优先：模糊点必须确认后再分析
- ✅ 多 Agent 协作：多维度任务自动拆分并行（2-6 个）

---

<details>
<summary>📖 实践指南（点击展开）</summary>

## Phase 3: 多 Agent 协作（关键）

### Agent 分发策略

❌ 错误："调用 /sc:design agent"
✅ 正确："启动 agent 专注于架构设计，重点分析模块接口定义的完整性、模块划分的清晰度、以及模块间依赖关系的合理性"

### 任务描述模板

| 维度 | Agent 描述 |
|------|-----------|
| 新功能 | 专注于架构设计（接口、模块、依赖） |
| Bug 修复 | 专注于诊断（根因、影响、修复） |
| 性能 | 分析瓶颈（复杂度、资源、优化） |
| 安全 | 识别漏洞（输入、权限、数据保护） |
| 重构 | 改进结构（可维护性、设计模式） |
| 测试 | 设计测试（类型、覆盖率、策略） |
| 文档 | 识别文档变更（API、指南、架构图） |
| 数据库 | 探索模式（表结构、关系、索引） |

### 并行执行

单条消息启动多个 agent（2-6 个），各自聚焦特定维度，等待全部完成后汇总。

**Agent 数量指南**：

| 任务复杂度 | 维度数 | 建议 Agent 数量 | 示例 |
|-----------|--------|----------------|------|
| 简单 | 2-3 | 2-3 | 单模块架构分析 |
| 中等 | 3-4 | 3-4 | 多模块重构 |
| 复杂 | 5-6 | 4-6 | 全系统设计 |

⚠️ **重要**：Agent 数量并非越多越好
- 3-4 个：并行收益最高（~1.8x）
- 5-6 个：仍有明显收益（~1.3x），但协调成本增加
- 不推荐超过 6 个（并行收益下降，协调困难）

## Phase 4: 代码探索与多维评估

### 多维检查清单
- [ ] **位置**：具体文件:行号
- [ ] **影响**：兼容性、现有功能
- [ ] **性能**：复杂度、资源
- [ ] **安全**：验证、权限、数据
- [ ] **测试**：测试用例、验证方法
- [ ] **文档**：需要更新的文档

## Phase 6: 验证与审查

### L1: 基础完整性（必须满足）
- [ ] 模糊点全部澄清
- [ ] 所有维度已分析
- [ ] 所有任务有具体位置（文件:行号）
- [ ] 依赖关系明确（前置/并行/交叉）

### L2: 分析深度（应该满足）
- [ ] 每个维度有具体发现
- [ ] 风险评估有具体缓解措施

### L3: 输出质量（优秀标准）
- [ ] 使用标准模板
- [ ] 提供完整示例代码

</details>

---

<details>
<summary>🔧 高级特性（点击展开）</summary>

## Agent 描述高级示例

### 架构设计示例
```
"启动 agent 专注于架构设计，重点分析：
1. 模块接口定义的完整性
2. 模块划分的清晰度（职责是否明确）
3. 模块间依赖关系的合理性（是否有循环依赖）
4. 数据流的可追踪性
5. 扩展性考虑

输出应包括：
- 当前架构的问题清单
- 改进建议（具体到接口级别）
- 架构图或依赖树"
```

### 性能优化示例
```
"启动 agent 专注于性能分析，重点评估：
1. 算法时间复杂度（是否有 O(n²) 可优化）
2. 空间复杂度（内存占用是否合理）
3. I/O 操作频率
4. 并发安全性

输出应包括：
- 性能瓶颈清单（具体到函数/代码行）
- 优化建议（带复杂度分析）
- 预期性能提升（如"预计提升 30%")"
```

## 错误处理策略

### 错误类型识别与处理

| 错误类型 | 识别方式 | 处理策略 | 回滚方案 | 预防措施 |
|---------|---------|---------|---------|---------|
| **需求理解错误** | 用户反馈偏离预期 | 立即澄清，重新开始 Phase 1 | 丢弃当前计划 | Phase 1 批量确认所有关键点 |
| **Agent 冲突** | 不同 Agent 建议矛盾 | 启动冲突解决流程，权衡优劣 | 选择最优方案 | 提前明确优先级和约束 |
| **代码探索失败** | 无法找到相关符号 | 切换探索策略（符号→文本→人工） | 回退到上一步骤 | 多种探索方法并行 |
| **依赖分析错误** | 循环依赖、关键路径不明确 | 重新梳理任务关系，拆分任务 | 合并任务或重新排序 | Phase 5 验证 DAG 性质 |
| **验证失败** | L1/L2 检查未通过 | 补充分析或重新生成 | 退回 Phase 4 补充 | Phase 6 强制检查点 |
| **执行中变更** | 用户中途修改需求 | 评估影响范围，增量更新计划 | 基于最近 Checkpoint | 设置频繁 Checkpoint |

### 回滚机制

**Checkpoint 策略**：
- **自动 Checkpoint**：每个 Phase 完成后
- **手动 Checkpoint**：关键里程碑（基础设施后、核心功能后）
- **紧急 Checkpoint**：发现重大问题前

**回滚流程**：
```
错误发现
  ↓
识别最近 Checkpoint
  ↓
评估回滚影响
  ├─ 影响 < 30% → 立即回滚
  ├─ 影响 30-70% → 询问用户
  └─ 影响 > 70% → 创建恢复计划
  ↓
执行回滚
  ↓
记录错误日志（用于改进）
```

## 质量标准分层

### L1: 基础完整性（必须）
- [ ] 模糊点全部澄清
- [ ] 所有任务有具体位置
- [ ] 依赖关系明确

### L2: 分析深度（应该）
- [ ] 每个维度有具体发现
- [ ] 风险评估有缓解措施

### L3: 输出质量（优秀）
- [ ] 使用标准模板
- [ ] 提供完整示例代码

</details>

---

# 核心原则（详细）

1. **渐进式发现**：描述任务需求，让 Claude 框架自动匹配工具（不列举工具名）
2. **澄清优先**：所有模糊点必须确认后再开始分析
3. **多 Agent 协作**：多维度任务自动拆分并行分析（2-6 个 Agent）
4. **文档同步**：代码变更与文档更新同步
5. **版本控制**：关键里程碑后及时 commit，commit 消息不包含作者信息

# Phase 1: 需求澄清

## 识别模糊点

分析请求中的模糊点：
- 未定义的行为（"优化性能"→哪方面？）
- 缺失的约束（兼容性？性能目标？）
- 缺失的细节（技术栈？版本？）
- 多种实现方式（哪种方案？）

## 批量确认

使用 `AskUserQuestion` **一次性**确认所有关键信息。只有全部明确后才能继续。

# Phase 2: 场景识别

## 维度检查

任务涉及哪些维度（可多选）：
- 新功能开发 / Bug 修复 / 性能优化
- 安全加固 / 代码重构 / 测试补充 / 文档更新

## 决策

```
维度 ≥ 2 个？
  → 是：进入 Phase 3（多 Agent 协作）
  → 否：进入 Phase 4（深度分析）
```

# Phase 3: 多 Agent 协作

## Agent 分发（关键！）

**原则**：构造任务描述，让框架自动选择工具。

❌ 错误："调用 /sc:design agent"
✅ 正确："启动 agent 专注于架构设计（接口、模块、数据流）"

### 任务描述模板

| 维度 | Agent 描述 |
|------|-----------|
| 新功能 | 专注于架构设计（接口、模块、依赖） |
| Bug 修复 | 专注于诊断（根因、影响、修复） |
| 性能 | 分析瓶颈（复杂度、资源、优化） |
| 安全 | 识别漏洞（输入、权限、数据保护） |
| 重构 | 改进结构（可维护性、设计模式） |
| 测试 | 设计测试（类型、覆盖率、策略） |
| 文档 | 识别文档变更（API、指南、架构图） |
| 数据库 | 探索模式（表结构、关系、索引） |

## 并行执行

单条消息启动多个 agent（2-6 个）：
- 每个一个 `Task` 调用
- 各自聚焦特定维度
- 等待全部完成

## 汇总

### 1. 依赖关系
识别任务间的依赖：前置、并行、交叉依赖

### 2. 解决冲突
不同 agent 建议冲突时：
- 列出方案优劣
- 选择最优并说明理由
- 考虑折中方案

### 3. 统一术语
确保命名一致（变量、函数、术语）

### 4. 拓扑排序
按依赖排序任务，明确关键路径

## 输出格式

```markdown
# 多 Agent 分析汇总

## 各维度专家意见
- 功能设计：...
- 安全分析：...
- ...

## 综合方案
### 依赖关系
[文本描述]

### 统一任务列表
1. [高] 任务（维度：功能+安全）
   - 位置：path:line
   - 操作：修改/新增/删除
   - 验证：如何确认
   - 文档更新：需要更新的文档
   - 依赖：[任务编号]

### 风险与权衡
- 冲突→解决
- 技术权衡说明
```

# Phase 4: 代码探索与多维评估

## 代码探索策略

✅ 正确："理解代码结构，选择合适工具探索符号和依赖"
❌ 错误："使用 mcp__serena__find_symbol 查找"

### 探索维度
- **符号层面**：类、函数、变量定义
- **依赖层面**：模块引用、接口实现
- **数据流层面**：数据如何在系统中流转

## 多维检查

- [ ] **位置**：具体文件:行号
- [ ] **影响**：兼容性、现有功能
- [ ] **性能**：复杂度、资源
- [ ] **安全**：验证、权限、数据
- [ ] **测试**：测试用例、验证方法
- [ ] **错误**：失败点、传播
- [ ] **边界**：空值、极端、并发
- [ ] **文档**：需要更新的文档（API、指南、README）

## 风险评估

识别风险（技术/兼容/性能/安全）+ 缓解措施

## 任务生成

### 任务格式

```markdown
N. [优先级] 任务（维度：...）

   位置：path:line
   操作：修改/新增/删除
   详情：具体改动
   验证：如何确认
   文档更新：需要更新的文档
   Commit：是否需要独立 commit（是/否）

   依赖：[任务编号]
   并行：[是/否]
```

### Checkpoint 设置

```markdown
[CHECKPOINT] 里程碑

完成标志：
- [ ] 标志1
- [ ] 标志2

Commit：是/否
Commit 类型：feat/fix/docs/refactor/test/chore
Commit 消息：简短描述（不包含作者信息）

风险：
问题→应对方案
```

**位置**：基础设施后、核心功能后、每个 major milestone

**Commit 原则**：
- 每个 CHECKPOINT 完成后建议进行 commit
- Commit 消息格式：`<类型>: 简短描述`
- **禁止**在 commit 消息中包含作者信息（如 "Co-Authored-By"）
- Commit 类型：
  - `feat:` 新功能
  - `fix:` Bug 修复
  - `docs:` 文档更新
  - `refactor:` 代码重构
  - `test:` 测试相关
  - `chore:` 构建/工具链相关

### 分段模式

- **自动**：每个 CHECKPOINT 暂停询问
- **手动**：标记 [PAUSE] 点
- **两者**：每次询问

# Phase 5: 计划生成与优化

## 计划优化要点

1. **依赖关系优化**：确保任务依赖形成 DAG（无环图）
2. **并行机会识别**：识别可以并行执行的任务
3. **关键路径分析**：确定影响总体工期的关键任务

## 风险与权衡

总结主要风险点和应对措施，平衡不同维度的需求。

# Phase 6: 验证与审查

## 1. 计划完整性检查

### L1: 基础完整性（必须满足）
- [ ] 模糊点全部澄清（Phase 1 确认）
- [ ] 所有维度已分析（Phase 3/4 覆盖）
- [ ] 所有任务有具体位置（文件:行号）
- [ ] 依赖关系明确（前置/并行/交叉）
- [ ] Checkpoint 已标记关键节点
- [ ] 文档任务已包含
- [ ] API 变更有文档任务

### L2: 分析深度（应该满足）
- [ ] 每个维度有具体发现（非泛泛而谈）
- [ ] 风险评估有具体缓解措施
- [ ] 任务操作明确（修改/新增/删除的具体内容）
- [ ] 验证方法可执行

### L3: 输出质量（优秀标准）
- [ ] 使用标准模板
- [ ] 提供完整示例代码
- [ ] 包含性能/安全指标
- [ ] 有回滚和错误处理方案

## 2. 依赖关系验证

### 验证步骤
1. 绘制任务依赖图（DAG）
2. 识别关键路径
3. 检查循环依赖
4. 验证并行可行性

### 依赖关系示例
```
任务1（基础设施）
  ↓
任务2（核心功能） ← 任务3（辅助功能）
  ↓                    ↓
    任务4（集成测试）
```

**验证要点**：
- 任务依赖形成 DAG（无环）
- 关键路径上的任务有 CHECKPOINT
- 并行任务之间无数据依赖

## 3. 风险评估复核

### 风险清单
| 风险 | 影响 | 概率 | 缓解措施 | 应急方案 |
|------|------|------|----------|----------|
| 模块加载性能下降 | 高 | 中 | 增加缓存机制 | 回滚到旧加载器 |
| 接口不兼容 | 中 | 低 | 提供适配器 | 维护双版本 API |
| 测试覆盖率不足 | 中 | 高 | 优先补充测试 | 增加人工测试 |

# Phase 7: 输出计划（标准化模板）

## 实施计划模板

```markdown
# [项目名称] 实施计划

## 📋 任务概览
- **总任务数**：X 个
- **阶段数**：Y 个
- **涉及维度**：功能、性能、安全、测试
- **预计复杂度**：高/中/低
- **关键路径**：任务1 → 任务5 → 任务12

---

## 🎯 阶段 1: [阶段名称]

### 目标
[简要描述本阶段目标]

### 任务列表

#### 1. [高/中/低] [任务名称]（维度：功能+安全）

**位置**：`path/to/file.py:123`

**操作**：修改/新增/删除

**详情**：
```python
# 具体代码示例
def new_function():
    pass
```

**验证**：
- [ ] 单元测试通过
- [ ] 代码审查完成
- [ ] 性能测试通过

**文档更新**：
- API 文档：`docs/api.md`
- 用户指南：`docs/guide.md`

**依赖**：[任务编号]
**并行**：是/否

**风险**：[潜在风险] → **缓解**：[应对措施]

---

### [CHECKPOINT] 阶段 1 完成

**完成标志**：
- [x] 所有任务已完成
- [x] 所有测试通过
- [x] 文档已更新

**恢复点**：任务列表 v1.0
**快照**：代码提交 hash

---

## 🎯 阶段 2: [阶段名称]

[重复上述格式]

---

## ⚠️ 风险与权衡

### 主要风险

| 风险 | 影响 | 概率 | 缓解措施 | 应急方案 |
|------|------|------|----------|----------|
| 模块加载性能下降 | 高 | 中 | 增加缓存机制 | 回滚到旧加载器 |
| 接口不兼容 | 中 | 低 | 提供适配器 | 维护双版本 API |

### 技术权衡

**权衡 1：性能 vs 可维护性**
- 决策：选择可维护性
- 理由：[说明原因]
- 影响：[预期效果]

---

## 📁 关键文件清单

### 需要修改的文件

```
src/ptk_repl/core/loaders/unified_loader.py     # 修改加载逻辑
src/ptk_repl/core/interfaces/loader.py          # 添加新接口
tests/test_loaders.py                           # 添加测试
docs/api-reference.md                           # 更新 API 文档
README.md                                       # 更新使用说明
```

### 新增文件

```
src/ptk_repl/core/cache/                        # 新增缓存模块
tests/integration/test_cache.py                 # 集成测试
docs/design/cache-design.md                     # 设计文档
```

---

## 🔍 质量检查清单

### L1: 基础完整性（必须）
- [x] 模糊点全部澄清
- [x] 所有维度已分析
- [x] 所有任务有具体位置
- [x] 依赖关系明确

### L2: 分析深度（应该）
- [x] 每个维度有具体发现
- [x] 风险评估有缓解措施
- [x] 任务操作明确

### L3: 输出质量（优秀）
- [x] 使用标准模板
- [x] 提供完整示例代码
- [x] 包含性能/安全指标

---

## 📊 预期成果

**量化指标**：
- 性能提升：30%
- 代码覆盖率：85% → 95%
- 文档完整性：100%

**定性改进**：
- 模块化程度：显著提升
- 可维护性：提升
- 扩展性：支持插件系统
```

# 配置（首次询问）

1. **分段**：自动/手动/两者
2. **深度**：标准/深度/极致
3. **检测**：自动/手动

# 核心使用原则

**关键**：描述要做什么，而非用什么工具。

✅ 正确："理解模块加载系统，探索符号和依赖关系"
❌ 错误："使用 find_symbol 查找 IModuleLoader"

**执行时记住**：
1. 先澄清再分析
2. 描述任务不列举工具
3. 多维度必用多 Agent（2-6 个）
4. 代码文档同步更新
5. 关键节点设 Checkpoint
6. 及时 Commit，消息不含作者信息